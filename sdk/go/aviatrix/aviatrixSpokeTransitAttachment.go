// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package aviatrix

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AviatrixSpokeTransitAttachment struct {
	pulumi.CustomResourceState

	// Indicates whether the maximum amount of HPE tunnels will be created. Only valid when transit and spoke gateways are each
	// launched in Insane Mode and in the same cloud type. Available as of provider version R2.22.2+.
	EnableMaxPerformance pulumi.BoolPtrOutput `pulumi:"enableMaxPerformance"`
	// Learned routes will be propagated to these route tables.
	RouteTables pulumi.StringArrayOutput `pulumi:"routeTables"`
	// Indicates whether the spoke gateway is BGP enabled or not.
	SpokeBgpEnabled pulumi.BoolOutput `pulumi:"spokeBgpEnabled"`
	// Name of the spoke gateway to attach to transit network.
	SpokeGwName pulumi.StringOutput `pulumi:"spokeGwName"`
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on spoke gateway.
	SpokePrependAsPaths pulumi.StringArrayOutput `pulumi:"spokePrependAsPaths"`
	// Name of the transit gateway to attach the spoke gateway to.
	TransitGwName pulumi.StringOutput `pulumi:"transitGwName"`
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on transit gateway.
	TransitPrependAsPaths pulumi.StringArrayOutput `pulumi:"transitPrependAsPaths"`
}

// NewAviatrixSpokeTransitAttachment registers a new resource with the given unique name, arguments, and options.
func NewAviatrixSpokeTransitAttachment(ctx *pulumi.Context,
	name string, args *AviatrixSpokeTransitAttachmentArgs, opts ...pulumi.ResourceOption) (*AviatrixSpokeTransitAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SpokeGwName == nil {
		return nil, errors.New("invalid value for required argument 'SpokeGwName'")
	}
	if args.TransitGwName == nil {
		return nil, errors.New("invalid value for required argument 'TransitGwName'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource AviatrixSpokeTransitAttachment
	err := ctx.RegisterResource("aviatrix:index/aviatrixSpokeTransitAttachment:AviatrixSpokeTransitAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAviatrixSpokeTransitAttachment gets an existing AviatrixSpokeTransitAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAviatrixSpokeTransitAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AviatrixSpokeTransitAttachmentState, opts ...pulumi.ResourceOption) (*AviatrixSpokeTransitAttachment, error) {
	var resource AviatrixSpokeTransitAttachment
	err := ctx.ReadResource("aviatrix:index/aviatrixSpokeTransitAttachment:AviatrixSpokeTransitAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AviatrixSpokeTransitAttachment resources.
type aviatrixSpokeTransitAttachmentState struct {
	// Indicates whether the maximum amount of HPE tunnels will be created. Only valid when transit and spoke gateways are each
	// launched in Insane Mode and in the same cloud type. Available as of provider version R2.22.2+.
	EnableMaxPerformance *bool `pulumi:"enableMaxPerformance"`
	// Learned routes will be propagated to these route tables.
	RouteTables []string `pulumi:"routeTables"`
	// Indicates whether the spoke gateway is BGP enabled or not.
	SpokeBgpEnabled *bool `pulumi:"spokeBgpEnabled"`
	// Name of the spoke gateway to attach to transit network.
	SpokeGwName *string `pulumi:"spokeGwName"`
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on spoke gateway.
	SpokePrependAsPaths []string `pulumi:"spokePrependAsPaths"`
	// Name of the transit gateway to attach the spoke gateway to.
	TransitGwName *string `pulumi:"transitGwName"`
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on transit gateway.
	TransitPrependAsPaths []string `pulumi:"transitPrependAsPaths"`
}

type AviatrixSpokeTransitAttachmentState struct {
	// Indicates whether the maximum amount of HPE tunnels will be created. Only valid when transit and spoke gateways are each
	// launched in Insane Mode and in the same cloud type. Available as of provider version R2.22.2+.
	EnableMaxPerformance pulumi.BoolPtrInput
	// Learned routes will be propagated to these route tables.
	RouteTables pulumi.StringArrayInput
	// Indicates whether the spoke gateway is BGP enabled or not.
	SpokeBgpEnabled pulumi.BoolPtrInput
	// Name of the spoke gateway to attach to transit network.
	SpokeGwName pulumi.StringPtrInput
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on spoke gateway.
	SpokePrependAsPaths pulumi.StringArrayInput
	// Name of the transit gateway to attach the spoke gateway to.
	TransitGwName pulumi.StringPtrInput
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on transit gateway.
	TransitPrependAsPaths pulumi.StringArrayInput
}

func (AviatrixSpokeTransitAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*aviatrixSpokeTransitAttachmentState)(nil)).Elem()
}

type aviatrixSpokeTransitAttachmentArgs struct {
	// Indicates whether the maximum amount of HPE tunnels will be created. Only valid when transit and spoke gateways are each
	// launched in Insane Mode and in the same cloud type. Available as of provider version R2.22.2+.
	EnableMaxPerformance *bool `pulumi:"enableMaxPerformance"`
	// Learned routes will be propagated to these route tables.
	RouteTables []string `pulumi:"routeTables"`
	// Name of the spoke gateway to attach to transit network.
	SpokeGwName string `pulumi:"spokeGwName"`
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on spoke gateway.
	SpokePrependAsPaths []string `pulumi:"spokePrependAsPaths"`
	// Name of the transit gateway to attach the spoke gateway to.
	TransitGwName string `pulumi:"transitGwName"`
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on transit gateway.
	TransitPrependAsPaths []string `pulumi:"transitPrependAsPaths"`
}

// The set of arguments for constructing a AviatrixSpokeTransitAttachment resource.
type AviatrixSpokeTransitAttachmentArgs struct {
	// Indicates whether the maximum amount of HPE tunnels will be created. Only valid when transit and spoke gateways are each
	// launched in Insane Mode and in the same cloud type. Available as of provider version R2.22.2+.
	EnableMaxPerformance pulumi.BoolPtrInput
	// Learned routes will be propagated to these route tables.
	RouteTables pulumi.StringArrayInput
	// Name of the spoke gateway to attach to transit network.
	SpokeGwName pulumi.StringInput
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on spoke gateway.
	SpokePrependAsPaths pulumi.StringArrayInput
	// Name of the transit gateway to attach the spoke gateway to.
	TransitGwName pulumi.StringInput
	// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on transit gateway.
	TransitPrependAsPaths pulumi.StringArrayInput
}

func (AviatrixSpokeTransitAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*aviatrixSpokeTransitAttachmentArgs)(nil)).Elem()
}

type AviatrixSpokeTransitAttachmentInput interface {
	pulumi.Input

	ToAviatrixSpokeTransitAttachmentOutput() AviatrixSpokeTransitAttachmentOutput
	ToAviatrixSpokeTransitAttachmentOutputWithContext(ctx context.Context) AviatrixSpokeTransitAttachmentOutput
}

func (*AviatrixSpokeTransitAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**AviatrixSpokeTransitAttachment)(nil)).Elem()
}

func (i *AviatrixSpokeTransitAttachment) ToAviatrixSpokeTransitAttachmentOutput() AviatrixSpokeTransitAttachmentOutput {
	return i.ToAviatrixSpokeTransitAttachmentOutputWithContext(context.Background())
}

func (i *AviatrixSpokeTransitAttachment) ToAviatrixSpokeTransitAttachmentOutputWithContext(ctx context.Context) AviatrixSpokeTransitAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AviatrixSpokeTransitAttachmentOutput)
}

// AviatrixSpokeTransitAttachmentArrayInput is an input type that accepts AviatrixSpokeTransitAttachmentArray and AviatrixSpokeTransitAttachmentArrayOutput values.
// You can construct a concrete instance of `AviatrixSpokeTransitAttachmentArrayInput` via:
//
//	AviatrixSpokeTransitAttachmentArray{ AviatrixSpokeTransitAttachmentArgs{...} }
type AviatrixSpokeTransitAttachmentArrayInput interface {
	pulumi.Input

	ToAviatrixSpokeTransitAttachmentArrayOutput() AviatrixSpokeTransitAttachmentArrayOutput
	ToAviatrixSpokeTransitAttachmentArrayOutputWithContext(context.Context) AviatrixSpokeTransitAttachmentArrayOutput
}

type AviatrixSpokeTransitAttachmentArray []AviatrixSpokeTransitAttachmentInput

func (AviatrixSpokeTransitAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AviatrixSpokeTransitAttachment)(nil)).Elem()
}

func (i AviatrixSpokeTransitAttachmentArray) ToAviatrixSpokeTransitAttachmentArrayOutput() AviatrixSpokeTransitAttachmentArrayOutput {
	return i.ToAviatrixSpokeTransitAttachmentArrayOutputWithContext(context.Background())
}

func (i AviatrixSpokeTransitAttachmentArray) ToAviatrixSpokeTransitAttachmentArrayOutputWithContext(ctx context.Context) AviatrixSpokeTransitAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AviatrixSpokeTransitAttachmentArrayOutput)
}

// AviatrixSpokeTransitAttachmentMapInput is an input type that accepts AviatrixSpokeTransitAttachmentMap and AviatrixSpokeTransitAttachmentMapOutput values.
// You can construct a concrete instance of `AviatrixSpokeTransitAttachmentMapInput` via:
//
//	AviatrixSpokeTransitAttachmentMap{ "key": AviatrixSpokeTransitAttachmentArgs{...} }
type AviatrixSpokeTransitAttachmentMapInput interface {
	pulumi.Input

	ToAviatrixSpokeTransitAttachmentMapOutput() AviatrixSpokeTransitAttachmentMapOutput
	ToAviatrixSpokeTransitAttachmentMapOutputWithContext(context.Context) AviatrixSpokeTransitAttachmentMapOutput
}

type AviatrixSpokeTransitAttachmentMap map[string]AviatrixSpokeTransitAttachmentInput

func (AviatrixSpokeTransitAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AviatrixSpokeTransitAttachment)(nil)).Elem()
}

func (i AviatrixSpokeTransitAttachmentMap) ToAviatrixSpokeTransitAttachmentMapOutput() AviatrixSpokeTransitAttachmentMapOutput {
	return i.ToAviatrixSpokeTransitAttachmentMapOutputWithContext(context.Background())
}

func (i AviatrixSpokeTransitAttachmentMap) ToAviatrixSpokeTransitAttachmentMapOutputWithContext(ctx context.Context) AviatrixSpokeTransitAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AviatrixSpokeTransitAttachmentMapOutput)
}

type AviatrixSpokeTransitAttachmentOutput struct{ *pulumi.OutputState }

func (AviatrixSpokeTransitAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AviatrixSpokeTransitAttachment)(nil)).Elem()
}

func (o AviatrixSpokeTransitAttachmentOutput) ToAviatrixSpokeTransitAttachmentOutput() AviatrixSpokeTransitAttachmentOutput {
	return o
}

func (o AviatrixSpokeTransitAttachmentOutput) ToAviatrixSpokeTransitAttachmentOutputWithContext(ctx context.Context) AviatrixSpokeTransitAttachmentOutput {
	return o
}

// Indicates whether the maximum amount of HPE tunnels will be created. Only valid when transit and spoke gateways are each
// launched in Insane Mode and in the same cloud type. Available as of provider version R2.22.2+.
func (o AviatrixSpokeTransitAttachmentOutput) EnableMaxPerformance() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AviatrixSpokeTransitAttachment) pulumi.BoolPtrOutput { return v.EnableMaxPerformance }).(pulumi.BoolPtrOutput)
}

// Learned routes will be propagated to these route tables.
func (o AviatrixSpokeTransitAttachmentOutput) RouteTables() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AviatrixSpokeTransitAttachment) pulumi.StringArrayOutput { return v.RouteTables }).(pulumi.StringArrayOutput)
}

// Indicates whether the spoke gateway is BGP enabled or not.
func (o AviatrixSpokeTransitAttachmentOutput) SpokeBgpEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *AviatrixSpokeTransitAttachment) pulumi.BoolOutput { return v.SpokeBgpEnabled }).(pulumi.BoolOutput)
}

// Name of the spoke gateway to attach to transit network.
func (o AviatrixSpokeTransitAttachmentOutput) SpokeGwName() pulumi.StringOutput {
	return o.ApplyT(func(v *AviatrixSpokeTransitAttachment) pulumi.StringOutput { return v.SpokeGwName }).(pulumi.StringOutput)
}

// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on spoke gateway.
func (o AviatrixSpokeTransitAttachmentOutput) SpokePrependAsPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AviatrixSpokeTransitAttachment) pulumi.StringArrayOutput { return v.SpokePrependAsPaths }).(pulumi.StringArrayOutput)
}

// Name of the transit gateway to attach the spoke gateway to.
func (o AviatrixSpokeTransitAttachmentOutput) TransitGwName() pulumi.StringOutput {
	return o.ApplyT(func(v *AviatrixSpokeTransitAttachment) pulumi.StringOutput { return v.TransitGwName }).(pulumi.StringOutput)
}

// AS Path Prepend customized by specifying AS PATH for a BGP connection. Applies on transit gateway.
func (o AviatrixSpokeTransitAttachmentOutput) TransitPrependAsPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AviatrixSpokeTransitAttachment) pulumi.StringArrayOutput { return v.TransitPrependAsPaths }).(pulumi.StringArrayOutput)
}

type AviatrixSpokeTransitAttachmentArrayOutput struct{ *pulumi.OutputState }

func (AviatrixSpokeTransitAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AviatrixSpokeTransitAttachment)(nil)).Elem()
}

func (o AviatrixSpokeTransitAttachmentArrayOutput) ToAviatrixSpokeTransitAttachmentArrayOutput() AviatrixSpokeTransitAttachmentArrayOutput {
	return o
}

func (o AviatrixSpokeTransitAttachmentArrayOutput) ToAviatrixSpokeTransitAttachmentArrayOutputWithContext(ctx context.Context) AviatrixSpokeTransitAttachmentArrayOutput {
	return o
}

func (o AviatrixSpokeTransitAttachmentArrayOutput) Index(i pulumi.IntInput) AviatrixSpokeTransitAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AviatrixSpokeTransitAttachment {
		return vs[0].([]*AviatrixSpokeTransitAttachment)[vs[1].(int)]
	}).(AviatrixSpokeTransitAttachmentOutput)
}

type AviatrixSpokeTransitAttachmentMapOutput struct{ *pulumi.OutputState }

func (AviatrixSpokeTransitAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AviatrixSpokeTransitAttachment)(nil)).Elem()
}

func (o AviatrixSpokeTransitAttachmentMapOutput) ToAviatrixSpokeTransitAttachmentMapOutput() AviatrixSpokeTransitAttachmentMapOutput {
	return o
}

func (o AviatrixSpokeTransitAttachmentMapOutput) ToAviatrixSpokeTransitAttachmentMapOutputWithContext(ctx context.Context) AviatrixSpokeTransitAttachmentMapOutput {
	return o
}

func (o AviatrixSpokeTransitAttachmentMapOutput) MapIndex(k pulumi.StringInput) AviatrixSpokeTransitAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AviatrixSpokeTransitAttachment {
		return vs[0].(map[string]*AviatrixSpokeTransitAttachment)[vs[1].(string)]
	}).(AviatrixSpokeTransitAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AviatrixSpokeTransitAttachmentInput)(nil)).Elem(), &AviatrixSpokeTransitAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*AviatrixSpokeTransitAttachmentArrayInput)(nil)).Elem(), AviatrixSpokeTransitAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AviatrixSpokeTransitAttachmentMapInput)(nil)).Elem(), AviatrixSpokeTransitAttachmentMap{})
	pulumi.RegisterOutputType(AviatrixSpokeTransitAttachmentOutput{})
	pulumi.RegisterOutputType(AviatrixSpokeTransitAttachmentArrayOutput{})
	pulumi.RegisterOutputType(AviatrixSpokeTransitAttachmentMapOutput{})
}
