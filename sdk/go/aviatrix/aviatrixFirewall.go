// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package aviatrix

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AviatrixFirewall struct {
	pulumi.CustomResourceState

	// Indicates whether enable logging or not. Valid values: true, false. Default value: false.
	BaseLogEnabled pulumi.BoolPtrOutput `pulumi:"baseLogEnabled"`
	// New base policy.
	BasePolicy pulumi.StringPtrOutput `pulumi:"basePolicy"`
	// The name of gateway.
	GwName pulumi.StringOutput `pulumi:"gwName"`
	// Enable to manage firewall policies via in-line rules. If false, policies must be managed using
	// `aviatrix_firewall_policy` resources.
	ManageFirewallPolicies pulumi.BoolPtrOutput `pulumi:"manageFirewallPolicies"`
	// New access policy for the gateway.
	Policies AviatrixFirewallPolicyTypeArrayOutput `pulumi:"policies"`
}

// NewAviatrixFirewall registers a new resource with the given unique name, arguments, and options.
func NewAviatrixFirewall(ctx *pulumi.Context,
	name string, args *AviatrixFirewallArgs, opts ...pulumi.ResourceOption) (*AviatrixFirewall, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.GwName == nil {
		return nil, errors.New("invalid value for required argument 'GwName'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource AviatrixFirewall
	err := ctx.RegisterResource("aviatrix:index/aviatrixFirewall:AviatrixFirewall", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAviatrixFirewall gets an existing AviatrixFirewall resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAviatrixFirewall(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AviatrixFirewallState, opts ...pulumi.ResourceOption) (*AviatrixFirewall, error) {
	var resource AviatrixFirewall
	err := ctx.ReadResource("aviatrix:index/aviatrixFirewall:AviatrixFirewall", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AviatrixFirewall resources.
type aviatrixFirewallState struct {
	// Indicates whether enable logging or not. Valid values: true, false. Default value: false.
	BaseLogEnabled *bool `pulumi:"baseLogEnabled"`
	// New base policy.
	BasePolicy *string `pulumi:"basePolicy"`
	// The name of gateway.
	GwName *string `pulumi:"gwName"`
	// Enable to manage firewall policies via in-line rules. If false, policies must be managed using
	// `aviatrix_firewall_policy` resources.
	ManageFirewallPolicies *bool `pulumi:"manageFirewallPolicies"`
	// New access policy for the gateway.
	Policies []AviatrixFirewallPolicyType `pulumi:"policies"`
}

type AviatrixFirewallState struct {
	// Indicates whether enable logging or not. Valid values: true, false. Default value: false.
	BaseLogEnabled pulumi.BoolPtrInput
	// New base policy.
	BasePolicy pulumi.StringPtrInput
	// The name of gateway.
	GwName pulumi.StringPtrInput
	// Enable to manage firewall policies via in-line rules. If false, policies must be managed using
	// `aviatrix_firewall_policy` resources.
	ManageFirewallPolicies pulumi.BoolPtrInput
	// New access policy for the gateway.
	Policies AviatrixFirewallPolicyTypeArrayInput
}

func (AviatrixFirewallState) ElementType() reflect.Type {
	return reflect.TypeOf((*aviatrixFirewallState)(nil)).Elem()
}

type aviatrixFirewallArgs struct {
	// Indicates whether enable logging or not. Valid values: true, false. Default value: false.
	BaseLogEnabled *bool `pulumi:"baseLogEnabled"`
	// New base policy.
	BasePolicy *string `pulumi:"basePolicy"`
	// The name of gateway.
	GwName string `pulumi:"gwName"`
	// Enable to manage firewall policies via in-line rules. If false, policies must be managed using
	// `aviatrix_firewall_policy` resources.
	ManageFirewallPolicies *bool `pulumi:"manageFirewallPolicies"`
	// New access policy for the gateway.
	Policies []AviatrixFirewallPolicyType `pulumi:"policies"`
}

// The set of arguments for constructing a AviatrixFirewall resource.
type AviatrixFirewallArgs struct {
	// Indicates whether enable logging or not. Valid values: true, false. Default value: false.
	BaseLogEnabled pulumi.BoolPtrInput
	// New base policy.
	BasePolicy pulumi.StringPtrInput
	// The name of gateway.
	GwName pulumi.StringInput
	// Enable to manage firewall policies via in-line rules. If false, policies must be managed using
	// `aviatrix_firewall_policy` resources.
	ManageFirewallPolicies pulumi.BoolPtrInput
	// New access policy for the gateway.
	Policies AviatrixFirewallPolicyTypeArrayInput
}

func (AviatrixFirewallArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*aviatrixFirewallArgs)(nil)).Elem()
}

type AviatrixFirewallInput interface {
	pulumi.Input

	ToAviatrixFirewallOutput() AviatrixFirewallOutput
	ToAviatrixFirewallOutputWithContext(ctx context.Context) AviatrixFirewallOutput
}

func (*AviatrixFirewall) ElementType() reflect.Type {
	return reflect.TypeOf((**AviatrixFirewall)(nil)).Elem()
}

func (i *AviatrixFirewall) ToAviatrixFirewallOutput() AviatrixFirewallOutput {
	return i.ToAviatrixFirewallOutputWithContext(context.Background())
}

func (i *AviatrixFirewall) ToAviatrixFirewallOutputWithContext(ctx context.Context) AviatrixFirewallOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AviatrixFirewallOutput)
}

// AviatrixFirewallArrayInput is an input type that accepts AviatrixFirewallArray and AviatrixFirewallArrayOutput values.
// You can construct a concrete instance of `AviatrixFirewallArrayInput` via:
//
//	AviatrixFirewallArray{ AviatrixFirewallArgs{...} }
type AviatrixFirewallArrayInput interface {
	pulumi.Input

	ToAviatrixFirewallArrayOutput() AviatrixFirewallArrayOutput
	ToAviatrixFirewallArrayOutputWithContext(context.Context) AviatrixFirewallArrayOutput
}

type AviatrixFirewallArray []AviatrixFirewallInput

func (AviatrixFirewallArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AviatrixFirewall)(nil)).Elem()
}

func (i AviatrixFirewallArray) ToAviatrixFirewallArrayOutput() AviatrixFirewallArrayOutput {
	return i.ToAviatrixFirewallArrayOutputWithContext(context.Background())
}

func (i AviatrixFirewallArray) ToAviatrixFirewallArrayOutputWithContext(ctx context.Context) AviatrixFirewallArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AviatrixFirewallArrayOutput)
}

// AviatrixFirewallMapInput is an input type that accepts AviatrixFirewallMap and AviatrixFirewallMapOutput values.
// You can construct a concrete instance of `AviatrixFirewallMapInput` via:
//
//	AviatrixFirewallMap{ "key": AviatrixFirewallArgs{...} }
type AviatrixFirewallMapInput interface {
	pulumi.Input

	ToAviatrixFirewallMapOutput() AviatrixFirewallMapOutput
	ToAviatrixFirewallMapOutputWithContext(context.Context) AviatrixFirewallMapOutput
}

type AviatrixFirewallMap map[string]AviatrixFirewallInput

func (AviatrixFirewallMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AviatrixFirewall)(nil)).Elem()
}

func (i AviatrixFirewallMap) ToAviatrixFirewallMapOutput() AviatrixFirewallMapOutput {
	return i.ToAviatrixFirewallMapOutputWithContext(context.Background())
}

func (i AviatrixFirewallMap) ToAviatrixFirewallMapOutputWithContext(ctx context.Context) AviatrixFirewallMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AviatrixFirewallMapOutput)
}

type AviatrixFirewallOutput struct{ *pulumi.OutputState }

func (AviatrixFirewallOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AviatrixFirewall)(nil)).Elem()
}

func (o AviatrixFirewallOutput) ToAviatrixFirewallOutput() AviatrixFirewallOutput {
	return o
}

func (o AviatrixFirewallOutput) ToAviatrixFirewallOutputWithContext(ctx context.Context) AviatrixFirewallOutput {
	return o
}

// Indicates whether enable logging or not. Valid values: true, false. Default value: false.
func (o AviatrixFirewallOutput) BaseLogEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AviatrixFirewall) pulumi.BoolPtrOutput { return v.BaseLogEnabled }).(pulumi.BoolPtrOutput)
}

// New base policy.
func (o AviatrixFirewallOutput) BasePolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AviatrixFirewall) pulumi.StringPtrOutput { return v.BasePolicy }).(pulumi.StringPtrOutput)
}

// The name of gateway.
func (o AviatrixFirewallOutput) GwName() pulumi.StringOutput {
	return o.ApplyT(func(v *AviatrixFirewall) pulumi.StringOutput { return v.GwName }).(pulumi.StringOutput)
}

// Enable to manage firewall policies via in-line rules. If false, policies must be managed using
// `aviatrix_firewall_policy` resources.
func (o AviatrixFirewallOutput) ManageFirewallPolicies() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AviatrixFirewall) pulumi.BoolPtrOutput { return v.ManageFirewallPolicies }).(pulumi.BoolPtrOutput)
}

// New access policy for the gateway.
func (o AviatrixFirewallOutput) Policies() AviatrixFirewallPolicyTypeArrayOutput {
	return o.ApplyT(func(v *AviatrixFirewall) AviatrixFirewallPolicyTypeArrayOutput { return v.Policies }).(AviatrixFirewallPolicyTypeArrayOutput)
}

type AviatrixFirewallArrayOutput struct{ *pulumi.OutputState }

func (AviatrixFirewallArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AviatrixFirewall)(nil)).Elem()
}

func (o AviatrixFirewallArrayOutput) ToAviatrixFirewallArrayOutput() AviatrixFirewallArrayOutput {
	return o
}

func (o AviatrixFirewallArrayOutput) ToAviatrixFirewallArrayOutputWithContext(ctx context.Context) AviatrixFirewallArrayOutput {
	return o
}

func (o AviatrixFirewallArrayOutput) Index(i pulumi.IntInput) AviatrixFirewallOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AviatrixFirewall {
		return vs[0].([]*AviatrixFirewall)[vs[1].(int)]
	}).(AviatrixFirewallOutput)
}

type AviatrixFirewallMapOutput struct{ *pulumi.OutputState }

func (AviatrixFirewallMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AviatrixFirewall)(nil)).Elem()
}

func (o AviatrixFirewallMapOutput) ToAviatrixFirewallMapOutput() AviatrixFirewallMapOutput {
	return o
}

func (o AviatrixFirewallMapOutput) ToAviatrixFirewallMapOutputWithContext(ctx context.Context) AviatrixFirewallMapOutput {
	return o
}

func (o AviatrixFirewallMapOutput) MapIndex(k pulumi.StringInput) AviatrixFirewallOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AviatrixFirewall {
		return vs[0].(map[string]*AviatrixFirewall)[vs[1].(string)]
	}).(AviatrixFirewallOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AviatrixFirewallInput)(nil)).Elem(), &AviatrixFirewall{})
	pulumi.RegisterInputType(reflect.TypeOf((*AviatrixFirewallArrayInput)(nil)).Elem(), AviatrixFirewallArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AviatrixFirewallMapInput)(nil)).Elem(), AviatrixFirewallMap{})
	pulumi.RegisterOutputType(AviatrixFirewallOutput{})
	pulumi.RegisterOutputType(AviatrixFirewallArrayOutput{})
	pulumi.RegisterOutputType(AviatrixFirewallMapOutput{})
}
